Ordo v2.1.0
===========

Symmetric Cryptography Library
------------------------------

This is the github repository for Ordo, a minimalist cryptography library with an emphasis on symmetric cryptography, which strives to meet high performance, portability, and security standards, while remaining modular in design to facilitate adding new features and maintaining existing ones. The library is written in standard C, but some sections are assembly-optimized for performance. Note that while the library is technically usable at this point, it is still very much a work in progress and mustn't be deployed in security-sensitive applications.

Status
------

What's new in 2.2:
 - new test driver, now enhanced with colored output and (more importantly) more flexible debugging features, no longer needs a file and awkward parsing code
 - fixed a bug in the CFB block mode where using the same buffer for plaintext and ciphertext would lead to loss of information
 - fixed a bug in all modes of operation where attempting to free a null pointer would lead to a segmentation fault
 - fixed a small memory leak
 - correctly rewrote functions which take no parameters as `(void)`
 - dedicated memory manager is now thread-safe, using `pthreads` for both Windows and Linux/BSD (but perhaps faster, system-specific mutexes could be used)
 - as a result of the previous bullet point, `Ordo` currently depends on `pthreads`, hopefully this will change soon as system-specific mutexes are implemented
 - finally put the problem of OpenBSD's `sys/endian.h` header to rest: nowhere is it said one needs to include `sys/types.h` before! Yay for self-contained headers (and bad error messages)

Overview
--------

The test driver is in the `tests` folder, and a few samples (including a benchmark program) are in `samples`. The documentation is autogenerated (if you have `doxygen`) and will place itself in the `docs` folder.

The design of the library is to have cryptographic primitives (be it block ciphers, hash functions, etc...) be accessible from everywhere in the code, so that different modules are able to access them transparently (like encrypting, hashing, authenticating, encrypting+authenticating, etc...). Suggested library module names:

primitives -> contains declarations for all crypto primitives (block and stream ciphers, hashes, etc...)
enc -> for encryption only (either using block ciphers with modes of operation (CBC, CTR, etc...) via enc_block, or with stream ciphers with enc_stream)
hash -> for hashing/digest operations (MD5, Skein, etc...)
auth -> for authentication-only modes of operation (HMAC, VMAC, etc...)
encauth -> for encryption+authentication modes (GCM, CCM, etc...)
random -> for pseudorandom number generation (using the OS-provided CSPRNG)

This way every part of the library is cleanly separated yet can share cryptographic code. It is not clear yet how much abstraction can be obtained from each individual section of the library - for block and stream cipher encryption the abstraction level is very high as block cipher modes of operation are quite modular and stream ciphers can literally be swapped in and out at will, but for "hash" for instance it will be much lower by the very nature of how hash functions are designed.

Feature Map
-----------

Essentially finished features are in **bold**, features currently in progress are in *italic*, and planned features are in standard font.

* **random**
* *primitives*
    * *block_ciphers*
        * **NullCipher**
        * **Threefish-256**
        * *AES*
    * *stream_ciphers*
        * **RC4**
    * *hash_functions*
        * **SHA-256**
        * **MD5**
        * *Skein-256*
    * misc
* **enc**
    * **enc_block**
        * **ECB**
        * **CBC**
        * **CTR**
        * **CFB**
        * **CFB**
    * **enc_stream**
* **hash**
* *auth*
    * **hmac**
* *kdf*
    * *PBKDF2 (w/ HMAC)*
* encauth
* *testing (test drivers)*
    * *vectors*
    * *performance*

This doesn't include every single feature but gives a high level overview:

 Block Ciphers | Stream Ciphers | Hash Functions | Modes | Authentication | Key Derivation | Misc
 ------------- | -------------- | -------------- | ----- | -------------- | -------------- | ----
 AES           | RC4            | MD5            | ECB   | HMAC           | PBKDF2         | CSPRNG
 Threefish-256 | -              | SHA-256        | CBC   | -              | -              | -
 -             | -              | Skein-256      | OFB   | -              | -              | -
 -             | -              | -              | CFB   | -              | -              | -
 -             | -              | -              | CTR   | -              | -              | -

Documentation
-------------

Ordo is documented for Doxygen, and you can automatically generate all documentation via `make doc`. The HTML documentation will be generated in `doc/html` and the LaTeX documentation will be generated in `doc/latex` (note you need `pdflatex` and a working LaTeX environment for this to work). Symlinks will be automatically created in the `doc` directory for your convenience.

How To Build
------------

As Ordo is somewhat environment-dependent (it needs to know, among others, the target operating system for some platform-specific API's such as memory locking, and the target processor's endianness and native word size for processor-specific optimizations) we use a custom makefile to facilitate the build process. The makefile is *not* set up for cross-compiling and you will need to set this up yourself if you wish to build for different operating systems. If you are building for the current operating system, then you may tweak the processor architecture and Ordo will optimize accordingly, but unless you know what you are doing you should just build for your current system.

In general, Ordo expects to be given the following information:

* Operating system, along with various system functions. This is provided by the compiler and Ordo will automatically select the right codepath based on the operating system the compiler is reportedly targeting.
* Endianness. This is provided by the system libraries, or inferred from the operating system (e.g. Windows is always little-endian). Byte-swapping functions need not be available as Ordo has its own fallback functions, but are recommended for efficiency.
* Processor architecture. This is, again, provided by the compiler based on compilation flags restricting or enabling instruction sets and other features.

The makefile is used as follows:

    make extra=[arguments to the compiler]

Where the `extra` argument is used to refine processor specification. For instance, if your processor supports the AES-NI instructions, you will want to pass `extra="-maes"`. If you want full optimization for your own system, you will want to provide `extra="-march=native"`. Those are passed directly to the compiler so you can provide extra architecture information if you have more information on your target processor, in order to optimize the library further.

If your operating system is supported by Ordo, it *will run* as everything has a standard C code path. However, if specific optimizations are not available for your system and/or processor architecture, performance may not be ideal.

Finally, there are a few additional configuration options possible:

* `make strip=1` will strip symbols from the the built libraries using the `strip` tool, generally making them a bit smaller.
* `make debug=1` will enable the debug build functionality, which will disable all optimizations and assembly code paths, and enable debugging symbols. By default, debug mode is not enabled.
* `make shared=1` will build a shared library (`libordo.so`) instead of a static one (`libordo.a`) by default. Note that you will need to `make clean` if you want to change from a static to a shared library, as the object files are not compatible between both library types (shared libraries require position independent code whereas static ones don't).

To build and run the tests, use `make tests` and `make run_tests`. To build the samples, use `make samples`. The samples will be built into the `samples/bin` directory where you can try them out. Note the `shared` makefile parameter also applies to the tests and samples, and is needed to ensure they build for the right thing.

If you want to have both a static and a shared library, first do `make` to build the static library, then `make clean_obj` to remove the object files (but not the newly created library) and finally `make shared=1`. You should probably then do another `make clean_obj` to remove the object files for consistency.

For most uses, the build process should go like this:

    make
    make tests
    make samples
    cd tests
    ./bin/tests # add "-color" if your terminal supports it

Finally, `make clean` will remove all generated files in the repository, leaving behind only original content.

Compatibility
-------------

The library has been tested against the following platforms:

* Linux i686
* Linux x64
* OpenBSD x64
* NetBSD x64
* Windows x64

The following compilers are supported:

* gcc
* MinGW (use `msys` for the makefiles to work, and perhaps `CC=gcc` when invoking the makefile)
* Clang (should work out of the box with `-no-integrated-as` since Clang doesn't use the same assembler as gcc - to work around this, sanitize the assembly files to conform to the `llvm` assembler used by Clang)

Conclusion
----------

Of course, do not use Ordo for anything other than testing or contributing for now! It can only be used once it has been completed and extensively checked (and even then, there may still be flaws and bugs, as in any other software).
