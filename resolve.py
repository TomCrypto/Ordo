#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" The purpose of this script is to extract struct definitions
    for primitives from source files that are being built (this
    is provided via command-line arguments) and write them into
    a header file so they can be made public to the user.       """

import sys, os

class Primitive:
    """ Holds a library primitive with limit information. """
    def __init__(self, name, prim_type, block_len = 0, digest_len = 0):
        self.name = name
        self.prim_type = prim_type
        self.block_len = block_len
        self.digest_len = digest_len

""" The list of primitives, must be listed in inverse order of dependency! """
primitives = [
    Primitive('rc4',               'STREAM'                                           ),
    Primitive('md5',               'HASH',             block_len = 64, digest_len = 16),
    Primitive('sha256',            'HASH',             block_len = 64, digest_len = 32),
    Primitive('skein256',          'HASH',             block_len = 32, digest_len = 32),
    Primitive('aes',               'BLOCK',            block_len = 16                 ),
    Primitive('threefish256',      'BLOCK',            block_len = 32                 ),
    Primitive('nullcipher',        'BLOCK',            block_len = 16                 ),
    Primitive('ecb',               'BLOCK_MODE'                                       ),
    Primitive('cbc',               'BLOCK_MODE'                                       ),
    Primitive('cfb',               'BLOCK_MODE'                                       ),
    Primitive('ofb',               'BLOCK_MODE'                                       ),
    Primitive('ctr',               'BLOCK_MODE'                                       ),
]

def extract(fd):
    """ Extracts a primitive structure from a file, fails if none is found. """
    source = fd.readlines()

    bgn = source.index("#if annotation\n") + 1 if "#if annotation\n" in source else len(source) + 1
    end = source.index("#endif /* annotation */\n") if "#endif /* annotation */\n" in source else -1

    if bgn <= end:
        return "".join(source[bgn:end])
    else:
        print "-- [resolve.py] Failed to resolve primitive structure for {0}".format(fd.name)
        sys.exit(-1)

def gen_polymorphic_struct(built_prims, prim_type):
    """ Generates the polymorphic structure (union) for a primitive type. """
    prim_count = sum(1 for p in built_prims if p[1].prim_type == prim_type)

    src =  "struct {0}_STATE\n".format(prim_type)
    src += "{\n"
    src += "    prim_t primitive;\n"

    if prim_count > 0:
        src += "\n"
        src += "    union\n"
        src += "    {\n"

        for (_, prim) in built_prims:
            if prim.prim_type == prim_type:
                src += "        struct {0}_STATE {1};\n".format(prim.name.upper(), prim.name)

        src += "    } jmp;\n"

    src += "};\n"
    return src

def get_block_len(built_prims, prim_type):
    """ Calculates the maximum block length for a given primitive type """
    retval = max(built_prims, key = lambda (_, p):
        p.block_len if p.prim_type == prim_type else 0)[1]
    return 1 if retval.block_len == 0 else retval.block_len

def get_digest_len(built_prims, prim_type):
    """ Calculates the maximum digest length for a given primitive type """
    retval = max(built_prims, key = lambda (_, p):
        p.digest_len if p.prim_type == prim_type else 0)[1]
    return 1 if retval.digest_len == 0 else retval.digest_len

if __name__ == "__main__":
    """ Main function - takes a list of file paths scheduled for compilation, parses
        them to work out which primitives are being built and generates the header.  """
    built_prims = []

    for path in sys.argv:
        for prim in primitives:
            if prim.name + '.c' in path:
                built_prims.append((path, prim))

    definitions  = "/* AUTOGENERATED - DO NOT EDIT */\n\n"
    definitions += "#ifndef ORDO_DEFINITIONS_H\n"
    definitions += "#define ORDO_DEFINITIONS_H\n"
    definitions += "\n"
    definitions += "#include \"ordo/common/identification.h\"\n"

    definitions += "\n"
    definitions += "#define HASH_BLOCK_LEN  {0}\n".format(get_block_len(built_prims,  'HASH'))
    definitions += "#define HASH_DIGEST_LEN {0}\n".format(get_digest_len(built_prims, 'HASH'))
    definitions += "#define BLOCK_BLOCK_LEN {0}\n".format(get_block_len(built_prims,  'BLOCK'))

    for (path, prim) in built_prims:
        with open(path, 'r') as fd:
            definitions += "\n"
            definitions += extract(fd)

    definitions += "\n" + gen_polymorphic_struct(built_prims, 'BLOCK')
    definitions += "\n" + gen_polymorphic_struct(built_prims, 'HASH')
    definitions += "\n" + gen_polymorphic_struct(built_prims, 'STREAM')
    definitions += "\n" + gen_polymorphic_struct(built_prims, 'BLOCK_MODE')
    definitions += "\n"
    definitions += "#endif\n"

    with open('include/ordo/definitions.h', 'w') as fd:
        fd.write(definitions)
