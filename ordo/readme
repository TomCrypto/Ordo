Ordo v0.1.9
-----------

########### BREAKING NEWS ###########
Please compile Ordo with the -mno-avx flag until further notice, GCC has a bug which causes it to produce invalid assembly on some processors (specifically, AVX2 opcodes on AVX1-capable processors), you DO NOT want to discover this the hard way like we did. This compiler flag will stop GCC using AVX instructions and will therefore negate the bug, but may have minimal performance implications. This limitation will be lifted once a patched version of GCC is released and tested.
########### BREAKING NEWS ###########

This directory contains a bunch of code files and headers for Ordo, along with a test unit. The end result will be a static/dynamic library, but for now it's just attached to a simple console program for tests. A simple makefile is provided with two build targets:
- make debug, which includes no optimizations and no platform-specific features
- make release, adding all optimizations and all features available to your platform (via -march=native)
A Code::Blocks project file (ordo.cbp) is also included for your (or rather my) convenience.

Current work is focused towards finishing the cipher interface. Important todo's:
 - make the primitive API more elegant (right now it's a mess, need to allocate primitive contexts instead of relying on an inflexible "key" struct - refer to the "encrypt" module which is "doing it right") [WORK IN PROGRESS]
 - renew the documentation which is now severely outdated in some places (and try and make it consistent)
 - improve the test unit (better parser + more official test vectors)
 - improve error handling (this is VERY important, the current handling code is inconsistent and not very elegant)
 - make the environment detection subsystem (environment.h) work a little better and also recognize OS as well as platform capabilities (e.g. 32/64, specific CPUID feature flags, etc...) in a consistent way [WORK IN PROGRESS]

Other todo's to keep in mind:
 - get Ordo up and running as an actual library (possibly including the test driver) once the cipher API is done

Documentation: The code in a few headers is documented for Doxygen. The doxyfile is not included but can easily be regenerated (it's just a configuration file).

:::Current status and what needs to be done:::

A basic test driver has been implemented, which reads a test vector file (see vectors file) by parsing a simple script. It allows to see if Ordo is correctly running at a glance - if you fail a test vector or get a segfault, you have a problem. Read the vectors file and the code in /testing/ to know more about this. Note the test vectors are sort of artificial so far (the only "official" ones are the first Threefish-256/ECB vector and RC4/STREAM one), but proper ones will be added once more cipher primitives are implemented.

CIPHERS > Modes of operation implemented: ECB, CBC, OFB, CFB, CTR, STREAM
CIPHERS > Primitives implemented: NullCipher, Threefish-256 [ASM-optimized for x86_64], RC4 [ASM-optimized for x86_64]
/!\ Threefish-256 and RC5-64/16 have not been extensively checked against test vectors yet, RC4 has though! /!\
CIPHERS > The API is actually usable at this stage, but still not definitive, parameters will be shuffled around and modified to improve effectiveness and flexibility.

Essentially we want primitives (be it cipher primitives, or hash primitives, etc...) to be accessible from everywhere in the library, and we want different uses to be able to access them transparently (like encrypting, hashing, authenticating, encrypting+authenticating, etc...). Suggested library section names:

primitives -> contains declarations for all crypto primitives (ciphers, hashes, etc...)
encrypt -> for encryption-only modes of operation (CBC, CTR, etc...)
hash -> for hashing modes of operation (MD5/MD, Skein/UBI, etc...)
auth -> for authentication-only modes of operation (HMAC, VMAC, etc...)
encauth -> for encryption+authentication modes (GCM, CCM, etc...)
random -> for pseudorandom number generation (using the OS-provided CSPRNG)

This way every part of the library is cleanly separated yet can share cryptographic code. It is not clear yet how much abstraction can be obtained from each individual section of the library - for "encrypt" the abstraction level is very high as block cipher modes of operation are quite modular, but for "hash" for instance it will be much lower by the very nature of how hash functions are designed.

Stream ciphers fit into the block cipher scheme by introducing a new parameter into the forward and inverse functions (only the forward function is used in stream ciphers) and feeding it an arbitrary length plaintext buffer - the forward function is required to generate the keystream of the appropriate length of the fly and exclusive-or it with the plaintext buffer to produce the ciphertext buffer. This is how the STREAM interface expects the primitive to behave.

--------

Please note that "NullCipher" is a test cipher which does absolutely nothing and is only used to test if the rest of the library works. Obviously, it should not be used for any other purpose (you knew that).

--------

List of define flags to pass during compilation and their actions:
ORDO_DEBUG: indicates this is a debug build, some specific features may be disabled if this flag is enabled (right now it does nothing except print that the flag is enabled at the very beginning)

-------

The code on Github should normally be functional in some way (unless we screwed a commit up), but of course it has only been tested under a limited number of platforms, so you may have to patch up the code to make it work under your compiler/OS, as what shows up as warnings or hints for us may come up as errors for you. Ordo also features a different code path for 32-bit and 64-bit platforms and also based on CPU feature flags for special instructions (we strive to provide decent to excellent performance) which is probably a compatibility black hole, so bear with us until we've got it all sorted out. Tested platforms so far:

- Linux Mint 13 [64-bit] GCC v4.6.3
- Debian (Unstable) [64-bit] GCC v4.7.1
- Windows 7 [32-bit] GCC v4.6.2 (+MinGW)
- Windows 7 [64-bit] GCC v4.7.1 (+MinGW)

GCC is the recommended compiler, as environmental symbols are somewhat compiler-dependent (but we will keep adding symbols as needed to increase compatibility).

If you are under Windows, you will need to modify a few things to make this work. First, replace the %zu flag by %d if your compiler complains about it, as MinGW doesn't implement that format flag for some reason. Then, fix any other warnings as needed. To compile, you can use the C::B project file, by changing the makefile settings (it is best to disable it and reset the build options manually - you can also go into Other Options and paste there the Makefile flags, this is important if you want the ORDO_DEBUG define in debug mode). Otherwise it should mostly compile out of the box on any common architecture. Let us know if it doesn't work for you and include all available information.

--------

Of course, do not use Ordo for anything other than testing or contributing for now! It can only be used once it has been completed and extensively checked (and even then, there may still be flaws and bugs, as in any other software).
