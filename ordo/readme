Ordo v1.0.1
-----------

########### BREAKING NEWS ###########
Please compile Ordo with the -mno-avx flag until further notice, GCC has a bug which causes it to produce invalid assembly on some processors (specifically, AVX2 opcodes on AVX1-capable processors) when using -march=native, you DO NOT want to discover this the hard way like we did. This compiler flag will stop GCC using AVX instructions and will therefore negate the bug, but may have minimal performance implications. This limitation will be lifted once a patched version of GCC is released and tested.
########### BREAKING NEWS ###########

This directory contains code and headers for the shared library Ordo. A simple makefile is provided with two build targets:
- make debug, which includes no optimizations and adds debug symbols
- make release, adding all optimizations for maximum performance
A Code::Blocks project file (ordo.cbp) is also included for your (or rather my) convenience. Note the Ordo library contains a test driver, which has been interfaced through a small test program which should have been shipped along with this library (see the test folder).

Documentation: The headers and assembly files are documented for Doxygen, the source files are not. The doxyfile is included, and the generated HTML documentation should be located in doc/html/index.html. For practical reasons, the documentation itself is not included in the repository and you will need to generate it yourself via doxygen. There is also "make documentation" which will attempt to call doxygen to automatically produce the documentation.

-------- STATUS --------

Current work is focused towards finishing the cipher interface. Important todo's:
 - improve error handling (more error checking, mostly)
 - wrap up the cipher API and move on to hashes

A basic test driver has been implemented, which reads a test vector file (see vectors file) by parsing a simple script. It allows to see if Ordo is correctly running at a glance - if you fail a test vector or get a segfault, you have a problem. Read the vectors file (in the test program) and the code in /testing/ to know more about this. Note the test vectors are sort of artificial so far (the only "official" ones are the first Threefish-256/ECB vector and RC4/STREAM one), but proper ones will be added once more cipher primitives are implemented.

The design of the library is to have cryptographic primitives (be it cipher primitives, or hash primitives, etc...) be accessible from everywhere in the code, so that different modules are able to access them transparently (like encrypting, hashing, authenticating, encrypting+authenticating, etc...). Suggested library section names:

primitives -> contains declarations for all crypto primitives (ciphers, hashes, etc...)
encrypt -> for encryption-only modes of operation (CBC, CTR, etc...)
hash -> for hashing modes of operation (MD5/MD, Skein/UBI, etc...)
auth -> for authentication-only modes of operation (HMAC, VMAC, etc...)
encauth -> for encryption+authentication modes (GCM, CCM, etc...)
random -> for pseudorandom number generation (using the OS-provided CSPRNG)

This way every part of the library is cleanly separated yet can share cryptographic code. It is not clear yet how much abstraction can be obtained from each individual section of the library - for "encrypt" the abstraction level is very high as block cipher modes of operation are quite modular, but for "hash" for instance it will be much lower by the very nature of how hash functions are designed.

Stream ciphers fit into the cipher primitive design by introducing a new parameter into the forward and inverse functions (only the forward function is used in stream ciphers) and feeding it an arbitrary length plaintext buffer - the forward function is required to generate the keystream of the appropriate length of the fly and exclusive-or it with the plaintext buffer to produce the ciphertext buffer. This is how the STREAM interface expects the primitive to behave - look at RC4 for an example of how it works. Note this allows the high-level encrypt API to work exactly the same for block ciphers and stream ciphers, but of course one should know the pros of cons of stream ciphers when using one.

Feature Map ([x] = essentially finished, [-] = in progress, [ ] = not started)

[x] random
[-] primitives
    [-] ciphers
        [x] NullCipher
        [x] Threefish-256
        [x] RC4
    [ ] hashes
    [ ] misc
[x] encrypt
    [x] ECB
    [x] CBC
    [x] CTR
    [x] CFB
    [x] CFB
    [x] STREAM
[ ] hash
[ ] auth
[ ] encauth
[-] testing
    [-] vectors
    [-] performance

-------- COMPILER FLAGS --------

List of define flags to pass during compilation and their actions:
ORDO_DEBUG: indicates this is a debug build, some specific features may be disabled if this flag is enabled (right now it does nothing except print that the flag is enabled at the very beginning)

------- HOW TO COMPILE -------

The code on Github should normally be functional in some way (unless we screwed a commit up), but of course it has only been tested under a limited number of platforms, so you may have to patch up the code to make it work under your compiler/OS, as what shows up as warnings or hints for us may come up as errors for you. Ordo also features a different code path for 32-bit and 64-bit platforms and also based on CPU feature flags for special instructions (we strive to provide decent to excellent performance) which is probably a compatibility black hole, so bear with us until we've got it all sorted out. Tested platforms so far:

- Linux Mint 13 [64-bit] GCC v4.6.3
- Debian (Unstable) [64-bit] GCC v4.7.1
- Windows 7 [32-bit] GCC v4.6.2 (+MinGW)
- Windows 7 [64-bit] GCC v4.7.1 (+MinGW)

GCC is the recommended compiler, as environmental symbols are somewhat compiler-dependent (but we will keep adding symbols as needed to increase compatibility).

Instructions for Linux: just use the makefile, and it should work out of the box. The C::B project file can be used too, if you have Code::Blocks installed.
Instructions For Windows:
  - if you use the makefiles (discouraged under Windows) you will need to edit them so as to replace the references to libordo.so by ordo.dll, and it should compile.
  - if you use the C::B project file, just disable the makefile and manually add the compiler flags in the build options, and add the DLL to the linker directories in the test program. Also change some output locations (use common sense) as C::B tends to make some assumptions which aren't usually the best. You should not have to change a single line of code except perhaps trivial compiler-specific things

-------- CONCLUSION --------

Of course, do not use Ordo for anything other than testing or contributing for now! It can only be used once it has been completed and extensively checked (and even then, there may still be flaws and bugs, as in any other software).
