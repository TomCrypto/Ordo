Ordo v0.1.5
-----------

This directory contains a bunch of code files and headers for Ordo, along with a test unit. The end result will be a static/dynamic library, but for now it's just attached to a simple console program for tests. A simple makefile is provided with two build targets:
- make debug, which includes no optimizations and no platform-specific features
- make release, adding all optimizations and all features available to your platform (via -march=native)
A Code::Blocks project file (ordo.cbp) is also included for your (or rather my) convenience.

Current work is focused towards finishing the cipher interface. Important todo's:
 - make the primitive API more elegant (right now it's a mess, need to allocate primitive contexts instead of relying on an inflexible "key" struct - refer to the "encrypt" module which is "doing it right")
 - renew the documentation which is now severely outdated in some places (and try and make it consistent)
 - improve the test unit (better parser + more official test vectors)
 - improve error handling (this is VERY important, the current handling code is inconsistent and not very elegant)
 - make the environment detection subsystem (environment.h) work a little better and also recognize OS as well as platform capabilities (e.g. 32/64, specific CPUID feature flags, etc...) in a consistent way [WORK IN PROGRESS]

Other todo's to keep in mind:
 - distribute the #includes in a more coherent fashion (right now they are scattered wherever they are needed)
 - get Ordo up and running as an actual library (possibly including the test driver) once the cipher API is done

Documentation: The code in a few headers is documented for Doxygen. The doxyfile is not included but can easily be regenerated (it's just a configuration file).

:::Current status and what needs to be done:::

A basic test driver has been implemented, which reads a test vector file (see vectors file) by parsing a simple script. It allows to see if Ordo is correctly running at a glance - if you fail a test vector or get a segfault, you have a problem. Read the vectors file and the code in /testing/ to know more about this. Note the test vectors are sort of artificial so far (the only "official" ones are the first Threefish-256/ECB vector and RC4/STREAM one), but proper ones will be added once more cipher primitives are implemented.

CIPHERS > Modes of operation implemented: ECB, CBC, OFB, CFB, CTR, STREAM
CIPHERS > Primitives implemented: NullCipher, Threefish-256 [+ASM-optimized], RC4, RC5-64/16
/!\ Threefish-256 and RC5-64/16 have not been extensively checked against test vectors yet, RC4 has though! /!\
CIPHERS > The API is actually usable at this stage, but still not definitive, parameters will be shuffled around and modified to improve effectiveness and flexibility.

Essentially we want primitives (be it cipher primitives, or hash primitives, etc...) to be accessible from everywhere in the library, and we want different uses to be able to access them transparently (like encrypting, hashing, authenticating, encrypting+authenticating, etc...). Suggested library section names:

primitives -> contains declarations for all crypto primitives (ciphers, hashes, etc...)
encrypt -> for encryption-only modes of operation (CBC, CTR, etc...)
hash -> for hashing modes of operation (MD5/MD, Skein/UBI, etc...)
auth -> for authentication-only modes of operation (HMAC, VMAC, etc...)
encauth -> for encryption+authentication modes (GCM, CCM, etc...)
random -> for pseudorandom number generation (using the OS-provided CSPRNG)

This way every part of the library is cleanly separated yet can share cryptographic code. It is not clear yet how much abstraction can be obtained from each individual section of the library - for "encrypt" the abstraction level is very high as block cipher modes of operation are quite modular, but for "hash" for instance it will be much lower by the very nature of how hash functions are designed.

It is not yet clear how stream ciphers fit into this scheme, they may require a different interface if they can't be woven in as a primitive. But who uses dedicated stream ciphers anymore? Although I have implemented RC4 with a degenerate 1-byte block cipher (8-byte, actually, for caching/performance reasons - see rc4.c) using a dedicated "mode of operation" (STREAM), and all stream ciphers should be able to be formalized in a similar fashion, but I am not sure if this is flexible enough.

--------

Please note that "NullCipher" is a test cipher which does absolutely nothing and is only used to test if the rest of the library works. Obviously, it should not be used for any other purpose (you knew that).

--------

The code on Github should normally be functional in some way (unless we screwed a commit up), but of course it has only been tested under a limited number of platforms, so you may have to patch up the code to make it work under your compiler/OS, as what shows up as warnings or hints for us may come up as errors for you. Ordo also features a different code path for 32-bit and 64-bit platforms and also based on CPU feature flags for special instructions (we strive to provide decent to excellent performance) which is probably a compatibility black hole, so bear with us until we've got it all sorted out. Tested platforms so far:

- Linux Mint 13 [64-bit] GCC v4.6.3
- Debian (Unstable) [64-bit] GCC v4.7.1
- Windows 7 [32-bit] GCC v4.6.2 (+MinGW)

GCC is the recommended compiler, as environmental symbols are somewhat compiler-dependent (but we will keep adding symbols as needed to increase compatibility).

If you are under Windows, you will need to modify a few things to make this work. First, replace the %zu flag by %d if your compiler complains about it. Then, fix any other warnings as needed. To compile, you can use the C::B project file, by changing the makefile settings (it is best to disable it and reset the build options manually - you can also go into Other Options and paste there the Makefile flags, this is important if you want the ORDO_DEBUG define in debug mode)

--------

Of course, do not use Ordo for anything other than testing or contributing for now! It can only be used once it has been completed and extensively checked (and even then, there may still be flaws and bugs, as in any other software).
